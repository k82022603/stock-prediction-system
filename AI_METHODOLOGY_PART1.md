# AI 시대의 소프트웨어 개발 방법론 - Part 1

## 전통적 개발 방법론의 진화

### 들어가며: 패러다임의 전환점에서

2025년 1월, 우리는 소프트웨어 개발 역사에서 가장 극적인 변화의 한가운데 서 있습니다. 이는 단순한 도구의 변화가 아닌, 개발이라는 행위 자체의 본질이 바뀌는 근본적인 전환입니다. Claude Code, GitHub Copilot, ChatGPT 같은 AI 도구들이 등장하기 전까지, 소프트웨어 개발은 여전히 인간이 키보드를 두드려 코드를 한 줄 한 줄 작성하는 작업이었습니다. 하지만 지금은 다릅니다.

이 문서는 실제로 AI를 활용하여 완전한 시스템을 구축한 경험을 바탕으로 작성되었습니다. React + Spring Boot + MyBatis + PostgreSQL 기반의 주식 예측 시스템을 약 4-5시간 만에 구축하면서, 우리는 새로운 개발 방식이 가져오는 가능성과 도전을 직접 경험했습니다. 이 과정에서 배운 것들을 공유하고자 합니다.

### 1. 워터폴 모델: 예측 가능성에 대한 추구

소프트웨어 공학의 초기, 1970년대에 등장한 워터폴 모델은 제조업의 생산 라인에서 영감을 받았습니다. 명확한 단계를 정의하고, 각 단계가 완료되어야만 다음 단계로 진행할 수 있다는 순차적 접근법이었습니다.

#### 워터폴의 5단계:

**1) 요구사항 분석 (Requirements Analysis)**

고객과 미팅을 반복하며 수백 페이지의 요구사항 문서를 작성합니다. 모든 기능, 제약조건, 성능 목표를 명시합니다. 이 단계에서 놓친 요구사항은 나중에 엄청난 비용을 발생시킵니다. 프로젝트 매니저와 비즈니스 분석가들이 고객 사무실과 개발팀 사이를 오가며 질문하고, 답변을 받고, 문서화합니다.

전형적인 요구사항 문서는 다음을 포함합니다:
- 기능 요구사항: 시스템이 무엇을 해야 하는가
- 비기능 요구사항: 성능, 보안, 확장성, 사용성
- 제약사항: 예산, 일정, 기술 스택, 법적 규제
- 사용자 스토리: 각 사용자 유형이 시스템과 어떻게 상호작용하는가

**2) 시스템 설계 (System Design)**

아키텍처 다이어그램, 데이터베이스 ERD, 클래스 다이어그램, 시퀀스 다이어그램을 그립니다. UML이 전성기를 누렸던 시절입니다. 경험 많은 아키텍트들이 며칠을 회의실에 모여 화이트보드에 박스와 화살표를 그립니다.

설계 단계에서 결정되는 주요 사항들:
- 시스템 아키텍처: 모놀리식? 마이크로서비스? N-tier?
- 데이터베이스 스키마: 정규화, 인덱스 전략, 파티셔닝
- API 설계: RESTful? SOAP? GraphQL?
- 보안 설계: 인증, 인가, 암호화
- 배포 전략: 온프레미스? 클라우드? 하이브리드?

**3) 구현 (Implementation)**

설계 문서를 보며 개발자들이 실제 코드를 작성합니다. Java, C++, C# 같은 언어로 수천, 수만 줄의 코드가 만들어집니다. 이 단계가 가장 오래 걸립니다.

개발자들은 하루 종일 IDE 앞에 앉아 있습니다:
- 오전: 클래스 설계를 코드로 변환
- 점심: 동료와 설계 이슈 토론
- 오후: 비즈니스 로직 구현
- 저녁: 버그 수정과 리팩토링

Git 커밋이 하루에 수십 개씩 쌓입니다. 코드 리뷰가 진행되고, Pull Request가 머지됩니다. 주간 회의에서 진행상황을 보고합니다.

**4) 테스트 (Testing)**

QA 팀이 투입되어 버그를 찾습니다. 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트를 거칩니다. 버그 리포트가 쌓이고, 개발자들은 밤샘 작업으로 수정합니다.

테스트의 종류:
- 단위 테스트: 개별 함수/메서드의 동작 검증
- 통합 테스트: 모듈 간 인터페이스 검증
- 시스템 테스트: 전체 시스템의 동작 검증
- 성능 테스트: 부하 상황에서의 응답 시간, 처리량
- 보안 테스트: 취약점 스캔, 침투 테스트
- 사용자 인수 테스트: 실제 사용자가 요구사항 충족 여부 검증

**5) 유지보수 (Maintenance)**

시스템이 배포된 후 발생하는 버그를 수정하고, 추가 요구사항을 반영합니다. 하지만 아키텍처를 바꾸기는 이미 너무 늦었습니다. 기술 부채가 쌓여갑니다.

#### 워터폴의 문제점

소프트웨어는 제조업과 달리 요구사항이 계속 변합니다. 6개월간 개발한 시스템이 완성되었을 때, 시장은 이미 변했고, 고객의 요구도 달라져 있습니다. "처음으로 돌아가서 다시 설계해야 한다"는 말을 듣게 되면, 그동안의 투자가 모두 물거품이 됩니다.

또한 고객은 실제로 동작하는 소프트웨어를 보기 전까지는 자신이 원하는 것이 무엇인지 정확히 모릅니다. 화면 목업과 실제 동작하는 시스템은 천지 차이입니다. "아, 이게 아닌데..."라는 말을 듣는 순간, 개발자들의 얼굴은 창백해집니다.

실제 통계에 따르면:
- 워터폴 프로젝트의 약 50%가 실패하거나 심각한 지연 발생
- 초기 요구사항의 60%가 프로젝트 중간에 변경됨
- 개발된 기능의 45%가 실제로는 거의 사용되지 않음
- 예산 초과가 평균 89%, 일정 지연이 평균 120%

### 2. 애자일 혁명: 변화를 받아들이다

2001년, 17명의 소프트웨어 개발자들이 미국 유타주 스노버드 스키 리조트에 모여 "애자일 선언문(Agile Manifesto)"을 작성했습니다. 이는 소프트웨어 개발에서 혁명적 사건이었습니다.

#### 애자일의 4가지 핵심 가치:

1. **프로세스와 도구보다 개인과 상호작용을**
   워터폴은 문서와 프로세스를 강조했습니다. 애자일은 사람 간의 소통을 더 중요하게 봅니다. 복잡한 JIRA 워크플로우보다 팀원들이 직접 대화하는 것이 낫습니다.

2. **포괄적인 문서보다 작동하는 소프트웨어를**
   100페이지 설계 문서보다 실제 돌아가는 프로토타입이 더 가치 있습니다. 고객은 문서가 아니라 소프트웨어를 사용합니다.

3. **계약 협상보다 고객과의 협력을**
   고객은 적이 아니라 파트너입니다. 변경 요청마다 추가 비용을 청구하는 대신, 함께 더 나은 제품을 만들어갑니다.

4. **계획을 따르기보다 변화에 대응하기를**
   6개월 전에 만든 계획이 지금도 유효할까요? 시장은 변하고, 기술은 발전하고, 고객의 니즈도 진화합니다. 계획은 참고용이지 절대적 기준이 아닙니다.

#### 스크럼: 애자일의 구체적 실천법

애자일은 철학이고, 스크럼은 그것을 실천하는 프레임워크입니다.

**스프린트 (Sprint):**
2-4주 단위의 개발 사이클입니다. 각 스프린트가 끝나면 배포 가능한 제품 인크리먼트가 나옵니다.

전형적인 2주 스프린트:
- 1일차 (월요일): 스프린트 계획 회의
  - 이번 스프린트에 무엇을 만들 것인가?
  - 각 작업의 복잡도는? (스토리 포인트 추정)
  - 팀의 역량(Velocity)으로 완료 가능한가?

- 2-9일차 (화-목): 개발
  - 매일 아침 15분 데일리 스탠드업
  - 각자 "어제 한 일, 오늘 할 일, 블로킹 이슈" 공유
  - 페어 프로그래밍, 코드 리뷰, 지속적 통합

- 10일차 (금요일): 스프린트 리뷰 & 회고
  - 아침: 고객에게 완성된 기능 시연
  - 오후: 팀 회고. 무엇이 잘됐고, 무엇을 개선할까?

**칸반: 흐름 중심 접근**
스크럼의 고정된 스프린트가 부담스러운 팀을 위한 대안입니다.

칸반 보드:
```
┌──────────┬──────────┬──────────┬──────────┐
│  To Do   │  Doing   │ Review   │  Done    │
├──────────┼──────────┼──────────┼──────────┤
│ Task A   │ Task D   │ Task G   │ Task J   │
│ Task B   │ Task E   │ Task H   │ Task K   │
│ Task C   │ Task F   │          │ Task L   │
│ ...      │          │          │ ...      │
└──────────┴──────────┴──────────┴──────────┘
```

각 열의 WIP(Work In Progress) 제한을 둡니다. 예: Doing에는 최대 3개 작업만. 이렇게 하면 멀티태스킹이 줄고, 완료 속도가 빨라집니다.
