# Stock Prediction System 개발자 가이드

## 목차
- [1. 시스템 개요](#1-시스템-개요)
- [2. 기술 스택 및 아키텍처](#2-기술-스택-및-아키텍처)
- [3. Spring Boot 백엔드 상세](#3-spring-boot-백엔드-상세)
- [4. React 프론트엔드 상세](#4-react-프론트엔드-상세)
- [5. 데이터베이스 설계](#5-데이터베이스-설계)
- [6. API 설계 및 통신](#6-api-설계-및-통신)
- [7. 보안 및 성능](#7-보안-및-성능)
- [8. 테스트 전략](#8-테스트-전략)
- [9. 배포 및 운영](#9-배포-및-운영)
- [10. 개발 프로세스](#10-개발-프로세스)

---

## 1. 시스템 개요

Stock Prediction System은 한국 주식 시장의 내일 주가를 예측하는 풀스택 웹 애플리케이션입니다. 이 시스템은 AI 기반 바이브 코딩 방법론을 통해 개발되었으며, 전체 개발 기간은 약 4-5시간에 불과했습니다.

### 1.1 핵심 기능

시스템은 크게 세 가지 핵심 기능을 제공합니다. 첫째, 한국 주요 상장 기업의 주식 목록을 조회할 수 있으며, 각 종목은 종목 코드, 종목명, 시장 구분 등의 정보를 포함합니다. 둘째, AI 알고리즘을 활용하여 다음 거래일의 주가를 예측하고, 예측값과 함께 신뢰도 수치를 제공합니다. 셋째, 실시간으로 예측 데이터를 시각화하여 사용자가 직관적으로 정보를 파악할 수 있도록 합니다.

### 1.2 프로젝트 배경

전통적인 소프트웨어 개발 방식에서는 이러한 시스템을 구축하는 데 보통 2-3개월이 소요되었습니다. 요구사항 정의, 설계, 구현, 테스트, 배포의 각 단계를 순차적으로 진행해야 했기 때문입니다. 하지만 Claude Code와 같은 AI 도구를 활용하면, 자연어로 "무엇을 만들고 싶은지"만 설명하면 AI가 전체 시스템 설계와 구현을 담당합니다.

본 프로젝트는 단 두 줄의 프롬프트로 시작되었습니다. 첫 번째 프롬프트는 "React + JBOSS + SpringBoot + PostgreSQL 기반 내일 한국 주식 시장 예측 시스템"이었고, 두 번째 프롬프트는 "mybatis 기반으로 정리해줘"였습니다. 이 간단한 요청만으로 전체 백엔드, 프론트엔드, 데이터베이스 스키마, 그리고 상세한 문서까지 모두 생성되었습니다.

---

## 2. 기술 스택 및 아키텍처

### 2.1 기술 스택 선택 이유

#### 백엔드: Spring Boot 3.2

Spring Boot는 Java 기반 엔터프라이즈 애플리케이션 개발의 사실상 표준입니다. 버전 3.2는 최신 Java 17의 기능을 완벽하게 활용하며, 자동 설정 기능을 통해 개발 생산성을 극대화합니다. Spring Boot를 선택한 주요 이유는 다음과 같습니다.

먼저, 방대한 생태계를 가지고 있습니다. Spring Data, Spring Security, Spring Batch 등 다양한 서브 프로젝트를 활용하여 대부분의 엔터프라이즈 요구사항을 충족할 수 있습니다. 둘째, 임베디드 톰캣을 내장하고 있어 별도의 애플리케이션 서버 없이도 독립적으로 실행 가능합니다. 셋째, 프로덕션 레벨의 기능들이 기본 제공됩니다. 헬스 체크, 메트릭 수집, 로깅 등 운영에 필요한 기능이 Spring Boot Actuator를 통해 제공됩니다.

#### MyBatis 3.0.3

MyBatis는 SQL 매퍼 프레임워크로, JPA와는 다른 접근 방식을 제공합니다. JPA는 객체 지향적으로 데이터를 다루지만, MyBatis는 SQL을 직접 작성하면서도 JDBC의 복잡성을 제거합니다.

MyBatis를 선택한 이유는 명확합니다. 첫째, 복잡한 쿼리에 대한 완벽한 제어가 가능합니다. 주식 예측 시스템은 다양한 조건의 복잡한 쿼리가 필요한데, MyBatis는 XML이나 어노테이션을 통해 SQL을 명시적으로 작성할 수 있습니다. 둘째, 학습 곡선이 완만합니다. SQL을 아는 개발자라면 누구나 쉽게 사용할 수 있으며, 기존 SQL 자산을 재활용하기도 용이합니다. 셋째, 성능 최적화가 쉽습니다. 쿼리를 직접 작성하므로 불필요한 조인이나 서브쿼리를 제거하고 최적화된 쿼리를 작성할 수 있습니다.

#### React 18

React는 페이스북에서 개발한 선언적 UI 라이브러리입니다. 버전 18에서는 동시성 렌더링, 자동 배칭 등의 성능 개선이 이루어졌습니다.

React를 선택한 이유는 다음과 같습니다. 첫째, 컴포넌트 기반 아키텍처로 UI를 재사용 가능한 작은 단위로 분리할 수 있습니다. 주식 목록, 예측 카드, 차트 등을 독립적인 컴포넌트로 개발하여 유지보수성을 높였습니다. 둘째, 가상 DOM을 활용한 효율적인 렌더링으로 실시간 데이터 업데이트 시에도 뛰어난 성능을 보장합니다. 셋째, 방대한 생태계와 커뮤니티 지원을 받을 수 있습니다. React Router, Redux, Axios 등 다양한 라이브러리를 쉽게 통합할 수 있습니다.

#### PostgreSQL 15

PostgreSQL은 오픈소스 관계형 데이터베이스 관리 시스템으로, 엔터프라이즈급 기능을 무료로 제공합니다.

PostgreSQL을 선택한 이유는 명확합니다. 첫째, ACID 트랜잭션을 완벽하게 지원하여 데이터 무결성을 보장합니다. 둘째, JSON 타입을 네이티브로 지원하여 유연한 데이터 구조를 저장할 수 있습니다. 예측 결과의 메타데이터를 JSON으로 저장하여 스키마 변경 없이 정보를 확장할 수 있습니다. 셋째, 고급 인덱싱 기능을 제공합니다. B-Tree, Hash, GiST, GIN 등 다양한 인덱스 타입을 지원하여 쿼리 성능을 최적화할 수 있습니다.

### 2.2 시스템 아키텍처

전체 시스템은 3-Tier 아키텍처를 따릅니다. 이는 소프트웨어 공학의 가장 기본적이면서도 검증된 패턴입니다.

#### Presentation Layer (프론트엔드)

사용자 인터페이스를 담당하는 계층으로, React 18로 구현되었습니다. 이 계층은 사용자의 입력을 받아 비즈니스 계층에 전달하고, 결과를 시각적으로 표현합니다. 주요 컴포넌트는 StockList, PredictionCard, Chart 등이 있으며, 각 컴포넌트는 단일 책임 원칙을 따라 설계되었습니다.

사용자가 특정 주식을 클릭하면, 해당 이벤트가 React의 상태 관리 시스템을 통해 처리됩니다. useState 훅을 사용하여 선택된 주식 정보를 관리하고, useEffect 훅을 통해 API 호출을 자동화합니다. 이러한 Hook 기반 접근 방식은 클래스 컴포넌트에 비해 코드량을 줄이고 가독성을 높입니다.

#### Business Layer (백엔드)

비즈니스 로직을 담당하는 계층으로, Spring Boot로 구현되었습니다. 이 계층은 다시 세 개의 하위 계층으로 구성됩니다.

Controller 계층은 HTTP 요청을 받아 적절한 Service로 라우팅합니다. RESTful API 설계 원칙을 따르며, GET, POST, PUT, DELETE 등의 HTTP 메서드를 의미에 맞게 사용합니다. 예를 들어, 주식 목록 조회는 GET /api/stocks, 새로운 예측 생성은 POST /api/predictions 형식입니다.

Service 계층은 실제 비즈니스 로직을 구현합니다. 주가 예측 알고리즘, 신뢰도 계산, 데이터 검증 등이 이 계층에서 수행됩니다. @Service 어노테이션으로 스프링 빈으로 등록되며, @Transactional 어노테이션을 통해 트랜잭션 관리가 자동으로 이루어집니다.

Mapper 계층은 MyBatis를 활용하여 데이터베이스와 통신합니다. XML 파일에 SQL 쿼리를 작성하고, Java 인터페이스를 통해 매핑합니다. 이 방식은 SQL과 Java 코드를 분리하여 유지보수성을 높입니다.

#### Data Layer (데이터베이스)

데이터 영속성을 담당하는 계층으로, PostgreSQL 15로 구현되었습니다. 주요 테이블은 stocks, stock_prices, predictions 세 가지입니다.

stocks 테이블은 종목 기본 정보를 저장합니다. 종목 코드, 종목명, 시장 구분 등을 포함하며, 종목 코드를 기본 키로 사용합니다. stock_prices 테이블은 일별 주가 데이터를 저장합니다. 시가, 고가, 저가, 종가, 거래량 등의 정보를 포함하며, 날짜와 종목 코드의 조합을 복합 기본 키로 사용합니다. predictions 테이블은 예측 결과를 저장합니다. 예측 날짜, 예측 가격, 신뢰도 등을 포함하며, 예측 ID를 기본 키로 사용합니다.

각 테이블 간의 관계는 외래 키로 정의됩니다. stock_prices와 predictions는 모두 stocks 테이블을 참조하며, ON DELETE CASCADE 옵션을 통해 종목 삭제 시 관련 데이터도 함께 삭제됩니다.

---

## 3. Spring Boot 백엔드 상세

### 3.1 프로젝트 구조

Spring Boot 프로젝트는 명확한 패키지 구조를 따릅니다. 일반적으로 기능 기반 또는 계층 기반으로 패키지를 구성하는데, 본 프로젝트는 계층 기반 구조를 채택했습니다.

com.stock 패키지 하위에 controller, service, mapper, model, dto, config 패키지가 있습니다. controller 패키지는 REST API 엔드포인트를 정의하며, service 패키지는 비즈니스 로직을 구현합니다. mapper 패키지는 MyBatis 매퍼 인터페이스를 포함하고, model 패키지는 도메인 객체를, dto 패키지는 데이터 전송 객체를 정의합니다. config 패키지는 Spring 설정 클래스를 포함합니다.

### 3.2 의존성 관리 (Maven)

Spring Boot 프로젝트는 Maven을 빌드 도구로 사용합니다. pom.xml 파일에 모든 의존성을 정의하며, Spring Boot Starter를 활용하여 관련 라이브러리를 한 번에 가져옵니다.

주요 의존성으로는 spring-boot-starter-web이 있습니다. 이는 웹 애플리케이션 개발에 필요한 Spring MVC, Tomcat, Jackson 등을 포함합니다. mybatis-spring-boot-starter는 MyBatis와 Spring Boot의 통합을 제공하며, 자동 설정 기능을 통해 복잡한 설정 없이 MyBatis를 사용할 수 있습니다. postgresql 드라이버는 PostgreSQL 데이터베이스와의 연결을 담당합니다.

롬복(Lombok) 라이브러리도 중요한 의존성입니다. @Data, @Builder, @NoArgsConstructor 등의 어노테이션을 통해 보일러플레이트 코드를 제거하고 가독성을 높입니다. 예를 들어, @Data 어노테이션 하나로 getter, setter, toString, equals, hashCode 메서드가 자동 생성됩니다.

### 3.3 application.yml 설정

Spring Boot는 application.yml 또는 application.properties 파일을 통해 설정을 관리합니다. YAML 형식은 계층 구조를 직관적으로 표현할 수 있어 선호됩니다.

데이터베이스 연결 정보는 spring.datasource 하위에 정의됩니다. url, username, password를 설정하며, HikariCP 커넥션 풀 설정도 포함됩니다. 최대 커넥션 수, 최소 유휴 커넥션 수, 커넥션 타임아웃 등을 조정하여 성능을 최적화할 수 있습니다.

MyBatis 설정은 mybatis 하위에 정의됩니다. mapper-locations는 XML 매퍼 파일의 위치를 지정하며, classpath:mapper/**/*.xml 패턴을 사용하여 모든 하위 디렉토리의 XML 파일을 스캔합니다. type-aliases-package는 도메인 객체의 패키지를 지정하여, XML에서 풀 패키지 이름 대신 클래스 이름만 사용할 수 있게 합니다.

로깅 설정도 중요합니다. logging.level 하위에 패키지별 로그 레벨을 지정할 수 있습니다. 개발 환경에서는 DEBUG 레벨로 상세한 로그를 확인하고, 운영 환경에서는 INFO 또는 WARN 레벨로 필요한 정보만 기록합니다.

### 3.4 MyBatis 통합

MyBatis는 SQL 매퍼 프레임워크로, 자바 객체와 SQL 쿼리를 매핑합니다. Spring Boot와의 통합은 매우 간단합니다.

첫째, 메인 애플리케이션 클래스에 @MapperScan 어노테이션을 추가합니다. 이 어노테이션은 매퍼 인터페이스가 위치한 패키지를 스캔하여 자동으로 스프링 빈으로 등록합니다. 둘째, 매퍼 인터페이스를 정의합니다. @Mapper 어노테이션을 추가하고, SQL 쿼리와 매핑될 메서드를 선언합니다. 셋째, XML 파일에 실제 SQL 쿼리를 작성합니다.

XML 매퍼 파일은 명확한 구조를 가집니다. mapper 태그의 namespace 속성은 매퍼 인터페이스의 풀 패키지 이름을 지정합니다. select, insert, update, delete 태그로 각 SQL 타입을 정의하며, id 속성은 인터페이스의 메서드 이름과 일치해야 합니다.

ResultMap은 복잡한 객체 매핑에 사용됩니다. 데이터베이스의 컬럼 이름과 자바 객체의 필드 이름이 다를 때, 또는 일대다 관계를 매핑할 때 유용합니다. association 태그로 일대일 관계를, collection 태그로 일대다 관계를 매핑할 수 있습니다.

### 3.5 REST API 설계

RESTful API 설계는 몇 가지 원칙을 따릅니다. 첫째, 리소스 중심 설계입니다. URL은 동사가 아닌 명사로 구성하며, HTTP 메서드로 동작을 표현합니다. 예를 들어, /api/stocks는 주식 리소스를 나타내고, GET은 조회, POST는 생성, PUT은 수정, DELETE는 삭제를 의미합니다.

둘째, 적절한 HTTP 상태 코드를 사용합니다. 성공 시 200 OK, 생성 시 201 Created, 잘못된 요청 시 400 Bad Request, 인증 실패 시 401 Unauthorized, 권한 없음 시 403 Forbidden, 리소스 없음 시 404 Not Found, 서버 오류 시 500 Internal Server Error를 반환합니다.

셋째, 일관된 응답 형식을 사용합니다. 모든 API는 동일한 구조의 JSON을 반환하며, success, data, message, timestamp 필드를 포함합니다. 이는 프론트엔드에서 응답을 처리하기 쉽게 만듭니다.

넷째, 버전 관리를 고려합니다. API URL에 /api/v1/stocks와 같이 버전을 포함시켜, 하위 호환성을 유지하면서 새로운 기능을 추가할 수 있습니다.

### 3.6 예외 처리 전략

견고한 애플리케이션은 예외를 적절히 처리해야 합니다. Spring Boot는 @ControllerAdvice와 @ExceptionHandler를 제공하여 전역 예외 처리를 지원합니다.

@ControllerAdvice 클래스를 생성하고, 각 예외 타입별로 @ExceptionHandler 메서드를 정의합니다. 예를 들어, ResourceNotFoundException이 발생하면 404 상태 코드와 함께 에러 메시지를 반환합니다. ValidationException은 400 상태 코드를, 일반적인 Exception은 500 상태 코드를 반환합니다.

로깅도 중요합니다. 모든 예외는 로그에 기록되어야 하며, 스택 트레이스와 함께 요청 정보(URL, 메서드, 파라미터)도 포함되어야 합니다. 이는 문제 발생 시 원인을 빠르게 파악하는 데 도움이 됩니다.

### 3.7 트랜잭션 관리

데이터 일관성을 보장하기 위해 트랜잭션 관리는 필수적입니다. Spring은 @Transactional 어노테이션을 통해 선언적 트랜잭션 관리를 제공합니다.

Service 클래스의 메서드에 @Transactional을 추가하면, 메서드 실행 전에 트랜잭션이 시작되고, 정상 종료 시 커밋, 예외 발생 시 롤백됩니다. propagation 속성으로 트랜잭션 전파 방식을 조정할 수 있으며, isolation 속성으로 격리 수준을 설정할 수 있습니다.

읽기 전용 트랜잭션은 readOnly=true 옵션을 사용합니다. 이는 데이터베이스에 힌트를 제공하여 성능을 최적화하고, 실수로 데이터가 수정되는 것을 방지합니다.

---

## 4. React 프론트엔드 상세

### 4.1 프로젝트 구조

React 프로젝트는 Create React App(CRA)을 기반으로 시작했습니다. CRA는 복잡한 Webpack 설정 없이 즉시 개발을 시작할 수 있게 해줍니다.

프로젝트 구조는 src 디렉토리 하위에 components, services, hooks, utils 디렉토리로 구성됩니다. components는 재사용 가능한 UI 컴포넌트를 포함하며, services는 API 통신 로직을, hooks는 커스텀 훅을, utils는 유틸리티 함수를 포함합니다.

### 4.2 컴포넌트 설계 원칙

React 컴포넌트는 단일 책임 원칙을 따라야 합니다. 각 컴포넌트는 하나의 명확한 목적을 가져야 하며, 너무 많은 책임을 지지 않아야 합니다.

본 프로젝트의 주요 컴포넌트는 다음과 같습니다. App 컴포넌트는 전체 애플리케이션의 루트이며, 레이아웃과 라우팅을 관리합니다. StockList 컴포넌트는 주식 목록을 표시하고, 사용자의 선택을 처리합니다. PredictionCard 컴포넌트는 개별 예측 결과를 카드 형태로 표시합니다. Chart 컴포넌트는 주가 데이터를 그래프로 시각화합니다.

각 컴포넌트는 Props를 통해 부모로부터 데이터를 받고, Callback을 통해 이벤트를 전달합니다. 이는 데이터 흐름을 단방향으로 유지하여 예측 가능성을 높입니다.

### 4.3 React Hooks 활용

React 18에서는 Hooks가 표준 패턴입니다. 주요 Hooks는 다음과 같습니다.

useState는 컴포넌트의 상태를 관리합니다. 선택된 주식, 로딩 상태, 에러 상태 등을 useState로 관리하며, 상태가 변경되면 자동으로 리렌더링됩니다.

useEffect는 사이드 이펙트를 처리합니다. API 호출, 이벤트 리스너 등록, 타이머 설정 등이 useEffect 내에서 수행됩니다. 의존성 배열을 통해 언제 이펙트를 실행할지 제어할 수 있습니다.

useContext는 전역 상태를 관리합니다. 여러 컴포넌트에서 공유되는 데이터(예: 사용자 정보, 테마 설정)를 Context API를 통해 전달하며, Props drilling을 방지합니다.

useMemo와 useCallback은 성능 최적화에 사용됩니다. useMemo는 계산 비용이 높은 값을 메모이제이션하고, useCallback은 함수를 메모이제이션하여 불필요한 리렌더링을 방지합니다.

### 4.4 API 통신 (Axios)

Axios는 Promise 기반 HTTP 클라이언트로, fetch API에 비해 더 풍부한 기능을 제공합니다.

Axios 인스턴스를 생성하여 baseURL, timeout, headers 등을 설정합니다. 이는 모든 API 호출에 일관된 설정을 적용하게 합니다. 인터셉터를 활용하여 요청 전 토큰을 추가하거나, 응답 후 에러를 전역적으로 처리할 수 있습니다.

API 호출은 try-catch 블록으로 감싸 에러를 처리합니다. 네트워크 오류, 타임아웃, 서버 오류 등 다양한 상황에 대응해야 합니다. 로딩 상태를 관리하여 사용자에게 피드백을 제공하고, 에러 발생 시 적절한 메시지를 표시합니다.

### 4.5 상태 관리 전략

소규모 애플리케이션에서는 React의 내장 상태 관리만으로 충분합니다. useState와 useContext를 조합하면 대부분의 요구사항을 충족할 수 있습니다.

하지만 애플리케이션이 복잡해지면 Redux나 Zustand 같은 상태 관리 라이브러리를 고려해야 합니다. Redux는 중앙 집중식 스토어를 제공하며, 시간 여행 디버깅, 미들웨어 등 강력한 기능을 제공합니다. Zustand는 더 간단한 API를 제공하며, 보일러플레이트 코드가 적습니다.

본 프로젝트는 규모가 작아 Context API만 사용했지만, 향후 기능 확장 시 Redux를 도입할 수 있습니다.

### 4.6 스타일링 전략

React에서 스타일링은 여러 방법이 있습니다. 전통적인 CSS 파일, CSS Modules, Styled Components, Tailwind CSS 등이 있습니다.

본 프로젝트는 CSS 파일을 사용했습니다. 각 컴포넌트마다 별도의 CSS 파일을 생성하여, 스타일을 모듈화했습니다. CSS 변수를 활용하여 색상, 간격 등을 일관되게 관리하고, 미디어 쿼리로 반응형 디자인을 구현했습니다.

Styled Components는 JavaScript 안에서 CSS를 작성하는 CSS-in-JS 방식입니다. 컴포넌트와 스타일을 함께 관리할 수 있어 유지보수성이 높지만, 런타임 오버헤드가 있습니다.

Tailwind CSS는 유틸리티 클래스 기반 프레임워크입니다. 빠른 개발이 가능하지만, HTML이 클래스 이름으로 복잡해질 수 있습니다.

---

## 5. 데이터베이스 설계

### 5.1 스키마 설계 원칙

관계형 데이터베이스 설계는 정규화를 기본 원칙으로 합니다. 정규화는 데이터 중복을 제거하고, 무결성을 보장하며, 이상 현상을 방지합니다.

본 프로젝트는 3차 정규형(3NF)까지 정규화했습니다. 1차 정규형은 모든 속성이 원자 값을 가지도록 하고, 2차 정규형은 부분 종속을 제거하며, 3차 정규형은 이행 종속을 제거합니다.

### 5.2 테이블 설계

stocks 테이블은 종목 기본 정보를 저장합니다. 주요 컬럼은 stock_code(기본 키), stock_name, market_type, sector, created_at, updated_at입니다. stock_code는 6자리 숫자로 구성된 한국거래소 표준 종목 코드입니다.

stock_prices 테이블은 일별 주가 데이터를 저장합니다. 주요 컬럼은 stock_code, price_date, open_price, high_price, low_price, close_price, volume입니다. stock_code와 price_date의 복합 기본 키를 사용하여, 특정 날짜의 특정 종목 주가는 유일함을 보장합니다.

predictions 테이블은 예측 결과를 저장합니다. 주요 컬럼은 prediction_id(기본 키), stock_code, target_date, predicted_price, confidence, created_at입니다. confidence는 0과 1 사이의 값으로, 예측의 신뢰도를 나타냅니다.

### 5.3 인덱스 전략

인덱스는 쿼리 성능을 크게 향상시키지만, 삽입/수정/삭제 성능은 저하시킵니다. 따라서 적절한 인덱스 전략이 필요합니다.

기본 키는 자동으로 클러스터형 인덱스가 생성됩니다. 외래 키도 인덱스를 생성하는 것이 좋습니다. stock_prices의 stock_code, predictions의 stock_code 등에 인덱스를 생성하여 조인 성능을 향상시킵니다.

자주 검색되는 컬럼에도 인덱스를 생성합니다. predictions의 target_date는 날짜별 예측을 조회하는 데 자주 사용되므로 인덱스를 생성합니다. 복합 인덱스도 고려할 수 있습니다. stock_code와 target_date를 함께 검색하는 경우가 많다면, 두 컬럼의 복합 인덱스를 생성합니다.

인덱스 사용 여부는 EXPLAIN 명령어로 확인할 수 있습니다. 쿼리 실행 계획을 분석하여 인덱스가 실제로 사용되는지, 풀 테이블 스캔이 발생하는지 확인합니다.

### 5.4 데이터 무결성

데이터 무결성은 데이터베이스의 정확성과 일관성을 보장합니다. 여러 수준의 제약 조건을 통해 구현됩니다.

NOT NULL 제약은 필수 컬럼에 NULL이 저장되는 것을 방지합니다. stock_code, stock_name, price_date 등 핵심 컬럼은 NOT NULL로 설정합니다.

UNIQUE 제약은 중복 값을 방지합니다. stock_code는 UNIQUE 제약이 있어 동일한 종목 코드가 두 번 입력되지 않습니다.

CHECK 제약은 값의 범위를 제한합니다. confidence는 0과 1 사이여야 하므로 CHECK (confidence >= 0 AND confidence <= 1) 제약을 추가합니다.

FOREIGN KEY 제약은 참조 무결성을 보장합니다. stock_prices의 stock_code는 stocks 테이블을 참조하며, 존재하지 않는 종목 코드는 입력할 수 없습니다. ON DELETE CASCADE 옵션으로 종목 삭제 시 관련 주가 데이터도 함께 삭제됩니다.

### 5.5 데이터베이스 마이그레이션

스키마 변경을 관리하기 위해 데이터베이스 마이그레이션 도구를 사용합니다. Flyway나 Liquibase가 대표적입니다.

Flyway는 SQL 파일 기반으로 마이그레이션을 관리합니다. V1__initial_schema.sql, V2__add_confidence_column.sql 같은 버전 관리된 SQL 파일을 순차적으로 실행하여 스키마를 변경합니다. 이미 실행된 마이그레이션은 flyway_schema_history 테이블에 기록되어 중복 실행을 방지합니다.

Liquibase는 XML, YAML, JSON 형식으로 마이그레이션을 정의할 수 있어 더 유연합니다. 롤백 기능도 지원하여 문제 발생 시 이전 상태로 복구할 수 있습니다.

---

## 6. API 설계 및 통신

### 6.1 RESTful API 설계

REST(Representational State Transfer)는 웹 서비스 설계의 아키텍처 스타일입니다. 리소스 중심, 무상태성, 캐시 가능성, 계층화 시스템 등의 원칙을 따릅니다.

리소스는 URI로 표현됩니다. /api/stocks는 주식 리소스의 컬렉션을, /api/stocks/005930은 특정 주식 리소스를 나타냅니다. HTTP 메서드로 동작을 표현합니다. GET은 조회, POST는 생성, PUT은 전체 수정, PATCH는 부분 수정, DELETE는 삭제입니다.

무상태성은 각 요청이 독립적임을 의미합니다. 서버는 클라이언트의 상태를 저장하지 않으며, 모든 필요한 정보는 요청에 포함되어야 합니다. 이는 확장성을 높이고, 서버 장애 시 복구를 쉽게 합니다.

### 6.2 API 버전 관리

API는 지속적으로 진화합니다. 새로운 기능 추가, 기존 기능 개선, 버그 수정 등이 이루어지는데, 기존 클라이언트와의 호환성을 유지하면서 변경하기 위해 버전 관리가 필요합니다.

URI 버전 관리는 가장 일반적인 방법입니다. /api/v1/stocks, /api/v2/stocks처럼 URI에 버전을 포함시킵니다. 명확하고 직관적이지만, URI가 변경되므로 캐싱에 불리할 수 있습니다.

헤더 버전 관리는 Accept 헤더나 커스텀 헤더에 버전을 지정합니다. Accept: application/vnd.myapp.v1+json 형식으로 사용합니다. URI가 변경되지 않아 깔끔하지만, 구현이 복잡합니다.

쿼리 파라미터 버전 관리는 /api/stocks?version=1처럼 쿼리 파라미터로 버전을 지정합니다. 간단하지만 RESTful 원칙에 어긋난다는 의견도 있습니다.

### 6.3 CORS 설정

CORS(Cross-Origin Resource Sharing)는 다른 도메인의 리소스에 접근을 허용하는 메커니즘입니다. 브라우저는 보안상 동일 출처 정책을 따르므로, 다른 도메인의 API를 호출하려면 CORS 설정이 필요합니다.

Spring Boot에서는 @CrossOrigin 어노테이션으로 간단히 설정할 수 있습니다. 컨트롤러 클래스나 메서드에 추가하며, origins 속성으로 허용할 도메인을 지정합니다.

전역 CORS 설정은 WebMvcConfigurer를 구현하여 설정합니다. 모든 API에 동일한 CORS 정책을 적용할 때 유용합니다. allowedOrigins, allowedMethods, allowedHeaders, allowCredentials 등을 설정할 수 있습니다.

운영 환경에서는 와일드카드(*) 대신 명시적으로 도메인을 지정해야 합니다. 보안 취약점을 방지하기 위해서입니다.

### 6.4 API 문서화

API 문서는 프론트엔드 개발자와 외부 개발자를 위해 필수적입니다. Swagger(OpenAPI)는 가장 널리 사용되는 API 문서화 도구입니다.

Springdoc OpenAPI를 사용하면 코드에서 자동으로 API 문서를 생성합니다. @Operation, @ApiResponse, @Parameter 등의 어노테이션으로 API를 설명하고, /swagger-ui.html에서 인터랙티브한 문서를 확인할 수 있습니다.

API 문서에는 엔드포인트 URL, HTTP 메서드, 요청 파라미터, 요청 본문, 응답 형식, 상태 코드, 예제가 포함되어야 합니다. 명확한 설명과 예제는 API 사용을 쉽게 만듭니다.

---

## 7. 보안 및 성능

### 7.1 보안 고려사항

#### SQL Injection 방지

MyBatis를 사용할 때 가장 주의해야 할 점은 SQL Injection입니다. 사용자 입력을 직접 SQL에 삽입하면 악의적인 SQL 코드가 실행될 수 있습니다.

MyBatis의 #{} 문법은 PreparedStatement를 사용하여 SQL Injection을 방지합니다. 반면 ${} 문법은 문자열 치환으로 위험합니다. 테이블명이나 컬럼명 같은 메타데이터에만 제한적으로 사용해야 합니다.

#### XSS 방지

XSS(Cross-Site Scripting)는 악의적인 스크립트를 웹 페이지에 삽입하는 공격입니다. React는 기본적으로 XSS를 방지하지만, dangerouslySetInnerHTML을 사용할 때는 주의해야 합니다.

사용자 입력을 HTML로 렌더링해야 한다면, DOMPurify 같은 라이브러리로 sanitize 해야 합니다. 또한 Content Security Policy(CSP) 헤더를 설정하여 스크립트 실행을 제한할 수 있습니다.

#### CSRF 방지

CSRF(Cross-Site Request Forgery)는 사용자가 의도하지 않은 요청을 보내도록 하는 공격입니다. Spring Security는 CSRF 토큰을 통해 방어합니다.

세션 기반 인증을 사용한다면 CSRF 보호를 활성화해야 하지만, JWT 같은 토큰 기반 인증은 CSRF에 안전합니다. 다만 XSS에는 취약하므로 토큰을 HttpOnly 쿠키에 저장하는 등의 조치가 필요합니다.

#### 인증과 인가

운영 환경에서는 반드시 인증과 인가를 구현해야 합니다. Spring Security와 JWT를 조합한 방식이 일반적입니다.

사용자가 로그인하면 JWT 토큰을 발급하고, 클라이언트는 이 토큰을 Authorization 헤더에 포함시켜 API를 호출합니다. 서버는 토큰을 검증하여 사용자 신원을 확인하고, 권한을 확인하여 접근을 제어합니다.

### 7.2 성능 최적화

#### 데이터베이스 최적화

쿼리 최적화는 성능의 핵심입니다. N+1 쿼리 문제를 방지하기 위해 즉시 로딩과 지연 로딩을 적절히 사용해야 합니다. MyBatis의 경우 association과 collection의 fetchType 속성으로 제어할 수 있습니다.

인덱스를 적절히 설계하면 쿼리 속도가 극적으로 향상됩니다. 하지만 과도한 인덱스는 쓰기 성능을 저하시키므로 균형이 필요합니다.

커넥션 풀 설정도 중요합니다. HikariCP의 maximumPoolSize, minimumIdle, connectionTimeout 등을 애플리케이션 특성에 맞게 조정해야 합니다.

#### 캐싱 전략

자주 조회되지만 변경이 드문 데이터는 캐싱하면 성능이 크게 향상됩니다. Spring Cache Abstraction을 사용하면 간단히 캐싱을 구현할 수 있습니다.

@Cacheable 어노테이션으로 메서드 결과를 캐싱하고, @CachePut으로 캐시를 업데이트하며, @CacheEvict로 캐시를 무효화합니다. Redis나 Caffeine 같은 캐시 프로바이더를 사용할 수 있습니다.

HTTP 캐싱도 고려해야 합니다. Cache-Control, ETag 헤더를 적절히 설정하면 불필요한 네트워크 요청을 줄일 수 있습니다.

#### 프론트엔드 최적화

React 애플리케이션의 성능 최적화는 여러 측면에서 이루어집니다. 코드 스플리팅으로 초기 로딩 시간을 단축하고, React.lazy와 Suspense를 활용하여 필요한 컴포넌트만 로드합니다.

이미지 최적화도 중요합니다. 적절한 포맷(WebP), 압축, lazy loading을 적용하여 로딩 시간을 줄입니다. Lighthouse 같은 도구로 성능을 측정하고 개선점을 찾을 수 있습니다.

---

## 8. 테스트 전략

### 8.1 테스트 피라미드

테스트는 단위 테스트, 통합 테스트, E2E 테스트로 구성되며, 피라미드 형태를 이룹니다. 단위 테스트가 가장 많고 빠르며, E2E 테스트는 적고 느립니다.

### 8.2 백엔드 테스트

#### 단위 테스트

JUnit 5와 Mockito를 사용하여 Service 계층을 테스트합니다. @Mock으로 의존성을 모킹하고, @InjectMocks로 테스트 대상에 주입합니다. given-when-then 패턴으로 테스트를 구조화하여 가독성을 높입니다.

#### 통합 테스트

@SpringBootTest로 Spring 컨텍스트를 로드하고, 실제 데이터베이스와 통합하여 테스트합니다. @Transactional을 추가하면 테스트 후 자동으로 롤백되어 데이터베이스가 깨끗한 상태를 유지합니다.

TestContainers를 사용하면 Docker 컨테이너에서 실제 PostgreSQL을 실행하여 테스트할 수 있습니다. 이는 운영 환경과 동일한 환경에서 테스트할 수 있어 신뢰성이 높습니다.

### 8.3 프론트엔드 테스트

React Testing Library를 사용하여 컴포넌트를 테스트합니다. 사용자 관점에서 테스트하는 것이 원칙이며, 구현 세부사항이 아닌 동작을 테스트합니다.

render로 컴포넌트를 렌더링하고, screen으로 요소를 찾으며, userEvent로 사용자 인터랙션을 시뮬레이션합니다. MSW(Mock Service Worker)로 API 호출을 모킹하여 백엔드 없이 프론트엔드를 테스트할 수 있습니다.

---

## 9. 배포 및 운영

### 9.1 빌드 및 패키징

#### 백엔드

Maven으로 프로젝트를 빌드하면 WAR 파일이 생성됩니다. mvn clean package 명령으로 target 디렉토리에 WAR 파일이 생성되며, 이를 JBoss/WildFly에 배포할 수 있습니다.

Spring Boot는 임베디드 톰캣을 포함하므로 java -jar로도 실행 가능합니다. 하지만 엔터프라이즈 환경에서는 JBoss 같은 애플리케이션 서버를 선호하는 경우가 많습니다.

#### 프론트엔드

npm run build 명령으로 프로덕션 빌드를 생성합니다. 빌드 결과는 build 디렉토리에 생성되며, 정적 파일(HTML, CSS, JS)로 구성됩니다. 이를 Nginx나 Apache 같은 웹 서버에서 서빙할 수 있습니다.

### 9.2 Docker 컨테이너화

Docker는 애플리케이션과 환경을 함께 패키징하여 일관된 배포를 가능하게 합니다. Dockerfile로 이미지를 정의하고, docker-compose로 여러 컨테이너를 오케스트레이션합니다.

백엔드 Dockerfile은 멀티 스테이지 빌드를 사용합니다. 첫 번째 스테이지에서 Maven으로 빌드하고, 두 번째 스테이지에서 JRE만 포함하여 이미지 크기를 줄입니다.

프론트엔드 Dockerfile도 멀티 스테이지 빌드를 사용합니다. 첫 번째 스테이지에서 npm으로 빌드하고, 두 번째 스테이지에서 Nginx에 정적 파일을 배포합니다.

docker-compose.yml은 백엔드, 프론트엔드, 데이터베이스를 함께 정의합니다. 네트워크, 볼륨, 환경 변수 등을 설정하여 전체 스택을 한 번에 실행할 수 있습니다.

### 9.3 CI/CD 파이프라인

GitHub Actions로 CI/CD 파이프라인을 구성합니다. PR 생성 시 자동으로 빌드와 테스트가 실행되고, main 브랜치에 머지되면 자동으로 배포됩니다.

워크플로우는 체크아웃, 의존성 설치, 빌드, 테스트, Docker 이미지 빌드, 레지스트리 푸시, 배포 단계로 구성됩니다. 각 단계가 실패하면 다음 단계는 실행되지 않으며, Slack이나 이메일로 알림이 전송됩니다.

### 9.4 모니터링과 로깅

운영 환경에서는 애플리케이션 상태를 지속적으로 모니터링해야 합니다. Spring Boot Actuator는 /actuator/health, /actuator/metrics 등의 엔드포인트를 제공하여 헬스 체크와 메트릭 수집을 지원합니다.

Prometheus로 메트릭을 수집하고 Grafana로 시각화하면, CPU 사용률, 메모리 사용량, API 응답 시간 등을 실시간으로 모니터링할 수 있습니다. 임계값을 설정하여 알림을 받을 수도 있습니다.

로깅은 Logback을 사용하며, JSON 형식으로 로그를 출력합니다. ELK 스택(Elasticsearch, Logstash, Kibana)으로 로그를 중앙 집중화하고, 검색과 분석을 수행할 수 있습니다.

---

## 10. 개발 프로세스

### 10.1 AI 기반 바이브 코딩

본 프로젝트는 Claude Code를 활용한 바이브 코딩으로 개발되었습니다. 전통적인 개발 방식과는 근본적으로 다른 접근입니다.

전통적 방식에서는 개발자가 직접 모든 코드를 타이핑합니다. 요구사항을 분석하고, 설계하고, 구현하고, 테스트하는 모든 단계를 수동으로 수행합니다. 이는 시간이 오래 걸리고, 반복 작업이 많으며, 사람에 따라 코드 품질이 일관되지 않습니다.

바이브 코딩에서는 개발자가 "무엇을 만들고 싶은지"만 자연어로 설명하면, AI가 전체 시스템을 설계하고 구현합니다. 개발자의 역할은 코더에서 아키텍트로 변화하며, 구현 세부사항보다는 비즈니스 로직과 사용자 경험에 집중할 수 있습니다.

### 10.2 효과적인 프롬프트 작성

좋은 프롬프트는 명확하고 구체적이며 맥락을 포함합니다. "주식 시스템 만들어줘"보다는 "React 18 + Spring Boot 3.2 + MyBatis + PostgreSQL 기반의 내일 한국 주식 시장 예측 시스템을 만들어줘. RESTful API로 설계하고, 반응형 UI를 구현해줘"가 훨씬 좋은 프롬프트입니다.

기술 스택을 명시하면 AI가 적절한 라이브러리와 패턴을 선택할 수 있습니다. 요구사항을 나열하면 필요한 기능을 빠짐없이 구현할 수 있습니다. 제약사항을 언급하면 불필요한 기능을 배제할 수 있습니다.

### 10.3 점진적 개선

바이브 코딩은 일회성이 아니라 반복적인 대화입니다. AI가 생성한 코드를 검토하고, 개선점을 요청하며, 새로운 기능을 추가합니다.

"예측 신뢰도 필드를 추가해줘", "에러 처리를 개선해줘", "로딩 상태를 표시해줘" 같은 구체적인 요청으로 시스템을 점진적으로 개선합니다. 각 단계에서 코드를 검토하고 테스트하여 품질을 보장합니다.

### 10.4 코드 검증

AI 생성 코드를 맹목적으로 신뢰해서는 안 됩니다. 반드시 검토하고 테스트해야 합니다. 아키텍처가 적절한지, 보안 취약점은 없는지, 성능은 괜찮은지 확인해야 합니다.

단위 테스트와 통합 테스트를 작성하여 기능을 검증하고, 코드 리뷰를 통해 품질을 높입니다. 정적 분석 도구(SonarQube, ESLint)로 코드 스멜을 찾아 개선합니다.

### 10.5 문서화

AI는 코드뿐만 아니라 문서도 생성할 수 있습니다. README, API 문서, 개발자 가이드, 운영 매뉴얼 등을 자동으로 생성하여 개발 시간을 절약할 수 있습니다.

하지만 생성된 문서도 검토가 필요합니다. 내용이 정확한지, 최신 정보를 반영하는지, 누락된 부분은 없는지 확인하고 수정해야 합니다.

---

## 결론

Stock Prediction System은 최신 기술 스택(Spring Boot 3.2, React 18, MyBatis 3.0, PostgreSQL 15)을 활용한 풀스택 웹 애플리케이션입니다. 전통적으로는 2-3개월이 소요되는 프로젝트를 AI 기반 바이브 코딩으로 4-5시간 만에 완성했습니다.

이 가이드는 서술형으로 작성되어 소스코드는 최소화하고 설명 위주로 구성되었습니다. 각 기술의 선택 이유, 아키텍처 설계 원칙, 개발 프로세스, 테스트 전략, 배포 방법을 상세히 다루었습니다.

핵심 포인트는 다음과 같습니다:

1. **명확한 아키텍처**: 3-Tier 아키텍처로 관심사를 명확히 분리
2. **적절한 기술 선택**: 각 레이어에 최적화된 기술 스택 사용
3. **보안 우선**: SQL Injection, XSS, CSRF 등 주요 보안 위협 방어
4. **성능 최적화**: 인덱싱, 캐싱, 코드 스플리팅 등 다양한 최적화 기법
5. **철저한 테스트**: 단위, 통합, E2E 테스트로 품질 보장
6. **자동화된 배포**: Docker와 CI/CD로 일관되고 안정적인 배포
7. **AI 활용**: 바이브 코딩으로 개발 생산성 극대화

이제 여러분도 이 가이드를 참고하여 최신 기술로 견고하고 확장 가능한 시스템을 구축할 수 있을 것입니다.

---

**작성자**: Claude Code  
**작성일**: 2025-12-06  
**버전**: 1.0  
**프로젝트**: Stock Prediction System  
**GitHub**: https://github.com/k82022603/stock-prediction-system

**관련 문서**:
- [CLAUDE.md](CLAUDE.md) - Claude Code 바이브 코딩 가이드
- [AI_METHODOLOGY_PART1.md](AI_METHODOLOGY_PART1.md) - AI 개발 방법론 Part 1
- [AI_METHODOLOGY_PART2.md](AI_METHODOLOGY_PART2.md) - AI 개발 방법론 Part 2
- [AI_METHODOLOGY_PART3.md](AI_METHODOLOGY_PART3.md) - AI 개발 방법론 Part 3
- [README.md](README.md) - 프로젝트 전체 가이드
